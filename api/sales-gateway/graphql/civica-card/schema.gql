
type CivicaCardReloadConversation {
  id: String ,
  timestamp: BigInt,

  userJwt: String,
  userName: String,

  posId: String,
  posUser: String,
  posTerminal: String,
  posLocation: [Float],

  operationState: String,
  readerType: String,
  cardType: String,
  cardUid: String,

  uiState: String,
  uiStateHistory: [String],
  # initCardData: CardData,
  # initCardState: String,
  # reloadValue: Int,
  # receipt: String,
  # business: String,
  # terminal: String,
  # endCardData: CardData,
  # endCardState: String,
}

type CivicaCardReloadSecondAuthToken {
  conversationId: String,
  token: String,  
}

input BinaryCommandInput {
  order: Int,
  cmd: String, 
  resp: String,
  cbc: String,
  rbc: String
}

type BinaryCommand {
  order: Int,
  cmd: String, 
  resp: String,
  cbc: String,
  rbc: String
}

input WriteAndReadBinaryCommandsInput {
  writeBinaryCommands: [BinaryCommandInput],
  readBinaryCommands:  [BinaryCommandInput],
}

type WriteAndReadBinaryCommands {
  writeBinaryCommands: [BinaryCommand],
  readBinaryCommands: [BinaryCommand],
}


type CivicaCardData {
  numeroTarjetaPublico: Int,
  identificacionEmpresa: Int,
  identificacionEmpleado: String,
  tipoNumeroDocumento: String,
  saldoTarjeta: Int,
  saldoTarjetaBk: Int,
  numeroTerminal: Int,
  formaPagoUsoTransporte: Int,
  fechaHoraTransaccion: Int,
  rutaUtilizada: Int,
  
  rutaAnterior: Int,
  valorPagoUsoTransporte: Int,
  secuenciaUsoTrayecto: Int,
  _saldoTarjeta: Int,
  numeroTarjetaDebito: Int,
  fechaUltimoDesbloqueoTarjeta: Int,
  fechaValidez: Int,
  fechaValidezVajeBeneficio: Int,
  perfilUsuario: Int,
  grupoPerfil: Int,
  numeroAcompannantes: Int,
  valorPagoSaldoCredito: Int,
  limiteUsoDiario: Int,
  codigoUltimaRecarga: Int,
  VersionMapping: Int,
  indicadorTarjetaBloqueada: Int,
  fechaHoraRecarga: Int,
  numeroSequenciaTransaccion: Int,
  pinStatus: Int,
  pinUsuario: Int,
  cantidadIntentosErroneos: Int,
  saldoCreditoBk: Int,
  saldoCredito: Int,
  saldoBeneficio: Int
}

type CivicaCardReloadPurchase {
  granted: Boolean,
  errorMsg: String,
  receipt: CivicaCardReloadPurchaseReceipt
}

type CivicaCardReloadPurchaseReceipt{
  id: String,
  timestamp: BigInt,

  reloadValue: Int,
  cardInitialValue: Int,
  cardFinalValue: Int,
  
  businesId: String,
  posId: String,
  posUserName: String,
  posUserId: String,
  posTerminal: String  
}


type Query{
  CivicaCardReloadConversation(id: ID!): CivicaCardReloadConversation @requireAuth
}

type Mutation {
  # abortCardReload(conversationId: String): AbortCardReloadResp,
  startCivicaCardReloadConversation(
    id: ID!,
    posId: String!,
    posUserName: String!,
    posUserId: String!,
    posTerminal: String,
    posLocation: [Float]!,
    readerType: String!,
    cardType: String!,
    cardUid: String!): CivicaCardReloadConversation @requireAuth

  setCivicaCardReloadConversationUiState(
    conversationId: String,
    uiState: String
  ): String @requireAuth

  generateCivicaCardReloadSecondAuthToken(
    conversationId: String,
    cardChallenge: String,
    cardRole: String
  ): CivicaCardReloadSecondAuthToken @requireAuth

  generateCivicaCardReloadReadApduCommands(
    conversationId: String!,
    cardAuthConfirmationToken: String,
    dataType: String
  ): [BinaryCommand]  @requireAuth

  processCivicaCardReloadReadApduCommandRespones(
    conversationId: String!,
    commands: [BinaryCommandInput]!
  ): CivicaCardData  @requireAuth

  purchaseCivicaCardReload(
    conversationId: String!,
    value: Int!
  ): CivicaCardReloadPurchase  @requireAuth

  generateCivicaCardReloadWriteAndReadApduCommands(
    conversationId: String!,
    cardAuthConfirmationToken: String,
    dataType: String!
  ): WriteAndReadBinaryCommands  @requireAuth


  processCivicaCardReloadWriteAndReadApduCommandResponses(
    conversationId: String,
    commands: WriteAndReadBinaryCommandsInput
  ): CivicaCardData  @requireAuth

}
















# type ReaderKey {
#   readerKey: String
# }

# type ReadCardSecondAuthToken {
#   authToken: String
# }

# type ReadCardApduCommands {
#   apduCommands: [String]
# }

# type CardData {
#   id: String
# }

# type CardReloadInfo {
#   cardReloadSaleToken: CardReloadSaleToken
#   writeApduCommands: [String],
#   readApduCommands: [String],
#   receipt: String
# }

# type CardReloadSaleToken {
#   state: String,
#   token: String
# }

# type ReadWriteCardData {
#   readCardData: [String],
#   writeCardData: [String]
# }

# type AbortCardReloadResp {
#   isAborted: Boolean
# }



# type Query {
#   #getReadCardSeconduthToken(conversationId: String, cardUid: String, challengeKey: String): ReadCardSecondAuthToken @requireAuth
#   # getReaderKey: ReaderKey @requireAuth
#   # getReadCardApduCommands(conversationId: String, cardAuthConfirmationToken: String): ReadCardApduCommands @requireAuth
#   # extractReadCardData(conversationId: String, apduResponses: [String]): CardData @requireAuth
#   # getCardReloadInfo(conversationId: String, cardAuthConfirmationToken: String, reloadValue: Int): CardReloadInfo @requireAuth
#   # extractReadWriteCardData(conversationId: String, readApduResp: [String], writeApduResp: [String]): ReadWriteCardData @requireAuth
#   # getConversation(conversationId: String): Conversation @requireAuth

# }
